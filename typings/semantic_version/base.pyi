from __future__ import annotations

import functools
from re import Pattern
from types import NotImplementedType
from typing import Any, Dict, Generator, Iterator, List, Literal, Tuple

class MaxIdentifier:
    __slots__: List[str] = ...

    def __repr__(self) -> Literal['MaxIdentifier()']:
        ...

    def __eq__(self, other: Any) -> bool:
        ...


@functools.total_ordering
class NumericIdentifier:
    __slots__: List[str] = ...

    def __init__(self, value: int) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __lt__(self, other: Any) -> bool:
        ...


@functools.total_ordering
class AlphaIdentifier:
    __slots__: List[str] = ...

    def __init__(self, value: str) -> None:
        ...

    def __repr__(self) -> str:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __lt__(self, other: Any) -> bool:
        ...


class Version:
    version_re: Pattern[str] = ...
    partial_version_re: Pattern[str] = ...

    def __init__(
        self,
        version_string: str | None = ...,
        major: str | None = ...,
        minor: str | None = ...,
        patch: str | None = ...,
        prerelease: str | None = ...,
        build: str | None = ...,
        partial: bool = ...
    ) -> None:
        ...

    def next_major(self) -> Version:
        ...

    def next_minor(self) -> Version:
        ...

    def next_patch(self) -> Version:
        ...

    def truncate(self, level: str = ...) -> Version:
        ...

    @classmethod
    def coerce(cls, version_string: str, partial: bool = ...) -> Version:
        ...

    @classmethod
    def parse(
        cls,
        version_string: str,
        partial: bool = ...,
        coerce: bool = ...
    ) -> Tuple[int, int, int, Tuple[str, ...], Tuple[str, ...]]:
        ...

    def __iter__(
        self
    ) -> Iterator[Tuple[int, int, int, Tuple[str, ...], Tuple[str, ...]]]:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def __hash__(self) -> int:
        ...

    @property
    def precedence_key(
        self
    ) -> tuple[int, int, int, tuple[NumericIdentifier | AlphaIdentifier, ...] |
               tuple[MaxIdentifier]]:
        ...

    def __cmp__(self, other: Any) -> NotImplementedType | Literal[-1, 1, 0]:
        ...

    def __eq__(self, other: Any) -> NotImplementedType | bool:
        ...

    def __ne__(self, other: Any) -> NotImplementedType | bool:
        ...

    def __lt__(self, other: Any) -> NotImplementedType | bool:
        ...

    def __le__(self, other: Any) -> NotImplementedType | bool:
        ...

    def __gt__(self, other: Any) -> NotImplementedType | bool:
        ...

    def __ge__(self, other: Any) -> NotImplementedType | bool:
        ...


class SpecItem:
    KIND_ANY: str = ...
    KIND_LT: str = ...
    KIND_LTE: str = ...
    KIND_EQUAL: str = ...
    KIND_SHORTEQ: str = ...
    KIND_EMPTY: str = ...
    KIND_GTE: str = ...
    KIND_GT: str = ...
    KIND_NEQ: str = ...
    KIND_CARET: str = ...
    KIND_TILDE: str = ...
    KIND_COMPATIBLE: str = ...
    KIND_ALIASES: Dict[str, str] = ...
    re_spec: Pattern[str] = ...

    def __init__(self, requirement_string: str, _warn: bool = ...) -> None:
        ...

    @classmethod
    def parse(
        cls, requirement_string: str
    ) -> tuple[Literal['*'], Literal['']] | tuple[str | Any, Version]:
        ...

    @classmethod
    def from_matcher(cls, matcher: Always | Never | Range) -> SpecItem | None:
        ...

    def match(
        self, version: str
    ) -> tuple[Literal['*'], Literal['']] | tuple[str | Any, Version]:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __hash__(self) -> int:
        ...


def compare(v1: str, v2: str) -> NotImplementedType | Literal[-1, 1, 0]:
    ...


def match(
    spec: str, version: str
) -> tuple[Literal['*'], Literal['']] | tuple[str | Any, Version]:
    ...


def validate(version_string: str) -> bool:
    ...


DEFAULT_SYNTAX: str = ...


class BaseSpec:
    SYNTAXES: Dict[str, type] = ...

    @classmethod
    def register_syntax(cls, subclass: object) -> object:
        ...

    def __init__(self, expression: str) -> None:
        ...

    @classmethod
    def parse(cls, expression: str, syntax: str = ...) -> BaseSpec:
        ...

    def filter(self, versions: List[str]) -> Generator[str, None, None]:
        ...

    def match(self, version: str) -> bool:
        ...

    def select(self, versions: List[str]) -> str | None:
        ...

    def __contains__(self, version: Version) -> bool:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __hash__(self) -> int:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...


class Clause:
    __slots__: List[str] = ...

    def match(self, version: str) -> bool:
        ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def prettyprint(self, indent: str = ...) -> str:
        ...

    def __ne__(self, other: Any) -> bool:
        ...

    def simplify(self) -> Clause:
        ...


class AnyOf(Clause):
    __slots__: List[str] = ...

    def __init__(self, *clauses: Any) -> None:
        ...

    def match(self, version: str) -> bool:
        ...

    def simplify(self) -> AnyOf:
        ...

    def __hash__(self) -> int:
        ...

    def __iter__(self) -> Iterator[Clause]:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...

    def __repr__(self) -> str:
        ...


class AllOf(Clause):
    __slots__: List[str] = ...

    def __init__(self, *clauses: Any) -> None:
        ...

    def match(self, version: str) -> bool:
        ...

    def simplify(self) -> AllOf:
        ...

    def __hash__(self) -> int:
        ...

    def __iter__(self) -> Iterator[Clause]:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...

    def __repr__(self) -> str:
        ...


class Matcher(Clause):
    __slots__: List[str] = ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...


class Never(Matcher):
    __slots__: List[str] = ...

    def match(self, version: str) -> Literal[False]:
        ...

    def __hash__(self) -> int:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...

    def __repr__(self) -> Literal['Never()']:
        ...


class Always(Matcher):
    __slots__: List[str] = ...

    def match(self, version: str) -> Literal[True]:
        ...

    def __hash__(self) -> int:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __and__(self, other: Any) -> bool:
        ...

    def __or__(self, other: Any) -> bool:
        ...

    def __repr__(self) -> Literal['Always()']:
        ...


class Range(Matcher):
    OP_EQ: str = ...
    OP_GT: str = ...
    OP_GTE: str = ...
    OP_LT: str = ...
    OP_LTE: str = ...
    OP_NEQ: str = ...
    PRERELEASE_ALWAYS: str = ...
    PRERELEASE_NATURAL: str = ...
    PRERELEASE_SAMEPATCH: str = ...
    BUILD_IMPLICIT: str = ...
    BUILD_STRICT: str = ...
    __slots__: List[str] = ...

    def __init__(
        self,
        operator: str,
        target: Version,
        prerelease_policy: str | None = ...,
        build_policy: str | None = ...
    ) -> None:
        ...

    def match(self, version: str) -> bool:
        ...

    def __hash__(self) -> int:
        ...

    def __eq__(self, other: Any) -> bool:
        ...

    def __str__(self) -> str:
        ...

    def __repr__(self) -> str:
        ...


@BaseSpec.register_syntax
class SimpleSpec(BaseSpec):
    SYNTAX: str = ...

    class Parser:
        NUMBER: str = ...
        NAIVE_SPEC: Pattern[str] = ...

        @classmethod
        def parse(cls, expression: str) -> Always:
            ...

        PREFIX_CARET: str = ...
        PREFIX_TILDE: str = ...
        PREFIX_COMPATIBLE: str = ...
        PREFIX_EQ: str = ...
        PREFIX_NEQ: str = ...
        PREFIX_GT: str = ...
        PREFIX_GTE: str = ...
        PREFIX_LT: str = ...
        PREFIX_LTE: str = ...
        PREFIX_ALIASES: Dict[str, str] = ...
        EMPTY_VALUES: List[str] = ...

        @classmethod
        def parse_block(cls, expr: str) -> Range:
            ...


class LegacySpec(SimpleSpec):  # type: ignore
    def __init__(self, *expressions: Any) -> None:
        ...

    @property
    def specs(self) -> list[SpecItem | None]:
        ...

    def __iter__(self) -> Generator[SpecItem | None, None, None]:
        ...


Spec = LegacySpec


@BaseSpec.register_syntax
class NpmSpec(BaseSpec):
    SYNTAX: str = ...

    class Parser:
        JOINER: str = ...
        HYPHEN: str = ...
        NUMBER: str = ...
        PART: str = ...
        NPM_SPEC_BLOCK: Pattern[str] = ...

        @classmethod
        def range(cls, operator: str, target: Version) -> Range:
            ...

        @classmethod
        def parse(cls, expression: str) -> Matcher:
            ...

        PREFIX_CARET: str = ...
        PREFIX_TILDE: str = ...
        PREFIX_EQ: str = ...
        PREFIX_GT: str = ...
        PREFIX_GTE: str = ...
        PREFIX_LT: str = ...
        PREFIX_LTE: str = ...
        PREFIX_ALIASES: Dict[str, str] = ...
        PREFIX_TO_OPERATOR: Dict[str, str] = ...
        EMPTY_VALUES: List[str] = ...

        @classmethod
        def parse_simple(cls, simple: str) -> List[Range]:
            ...
